/* Generated By:JJTree&JavaCC: Do not edit this line. MlirParser.java */
package pt.up.fe.specs.mlir.parser;

/**
 * Based on https://mlir.llvm.org/docs/LangRef/
 *
 * Changes:<br>
 * <li>bb-arg-list interpreted as block-arg-list</li>
 * <li>Added alias-name ::= bare-id</li>
 * <li>Added function-type ::= type</li>
 *
 * 
 */
public class MlirParser/*@bgen(jjtree)*/implements MlirParserTreeConstants, MlirParserConstants {/*@bgen(jjtree)*/
  protected JJTMlirParserState jjtree = new JJTMlirParserState();

/* IDENTIFIERS */
/*TOKEN : {  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}*/



//< ID_PUNCT: ["$", ".", "_", "-"] > |
  final public void IdPunct() throws ParseException {
                 /*@bgen(jjtree) IdPunct */
  SimpleNode jjtn000 = new SimpleNode(JJTIDPUNCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 14:
        jj_consume_token(14);
        break;
      case 15:
        jj_consume_token(15);
        break;
      case 16:
        jj_consume_token(16);
        break;
      case 17:
        jj_consume_token(17);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

//bare-id ::= (letter|[_]) (letter|digit|[_$.])*
  final public void BareId() throws ParseException {
                /*@bgen(jjtree) BareId */
  SimpleNode jjtn000 = new SimpleNode(JJTBAREID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LETTER:
        jj_consume_token(LETTER);
        break;
      case 16:
        jj_consume_token(16);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGIT:
        case LETTER:
        case 14:
        case 15:
        case 16:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LETTER:
          jj_consume_token(LETTER);
          break;
        case DIGIT:
          jj_consume_token(DIGIT);
          break;
        case 16:
          jj_consume_token(16);
          break;
        case 14:
          jj_consume_token(14);
          break;
        case 15:
          jj_consume_token(15);
          break;
        default:
          jj_la1[3] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// bare-id-list ::= bare-id (`,` bare-id)*
  final public void BareIdList() throws ParseException {
                    /*@bgen(jjtree) BareIdList */
  SimpleNode jjtn000 = new SimpleNode(JJTBAREIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      BareId();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 18:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_2;
        }
        jj_consume_token(18);
        BareId();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//suffix-id ::= (digit+ | ((letter|id-punct) (letter|id-punct|digit)*))
  final public void SuffixId() throws ParseException {
                  /*@bgen(jjtree) SuffixId */
  SimpleNode jjtn000 = new SimpleNode(JJTSUFFIXID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
        label_3:
        while (true) {
          jj_consume_token(DIGIT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DIGIT:
            ;
            break;
          default:
            jj_la1[5] = jj_gen;
            break label_3;
          }
        }
        break;
      case LETTER:
      case 14:
      case 15:
      case 16:
      case 17:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LETTER:
          jj_consume_token(LETTER);
          break;
        case 14:
        case 15:
        case 16:
        case 17:
          IdPunct();
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DIGIT:
          case LETTER:
          case 14:
          case 15:
          case 16:
          case 17:
            ;
            break;
          default:
            jj_la1[7] = jj_gen;
            break label_4;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LETTER:
            jj_consume_token(LETTER);
            break;
          case 14:
          case 15:
          case 16:
          case 17:
            IdPunct();
            break;
          case DIGIT:
            jj_consume_token(DIGIT);
            break;
          default:
            jj_la1[8] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//value-id ::= `%` suffix-id
  final public void ValueId() throws ParseException {
                 /*@bgen(jjtree) ValueId */
  SimpleNode jjtn000 = new SimpleNode(JJTVALUEID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(19);
      SuffixId();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// symbol-ref-id ::= `@` (suffix-id | string-literal)
  final public void SymbolRefId() throws ParseException {
                     /*@bgen(jjtree) SymbolRefId */
  SimpleNode jjtn000 = new SimpleNode(JJTSYMBOLREFID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(20);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case LETTER:
      case 14:
      case 15:
      case 16:
      case 17:
        SuffixId();
        break;
      case STRING_LITERAL:
        jj_consume_token(STRING_LITERAL);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// value-id-list ::= value-id (`,` value-id)*
  final public void ValueIdList() throws ParseException {
                     /*@bgen(jjtree) ValueIdList */
  SimpleNode jjtn000 = new SimpleNode(JJTVALUEIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ValueId();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 18:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_5;
        }
        jj_consume_token(18);
        ValueId();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//value-use ::= value-id
  final public void ValueUse() throws ParseException {
                  /*@bgen(jjtree) ValueUse */
  SimpleNode jjtn000 = new SimpleNode(JJTVALUEUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ValueId();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// value-use-list ::= value-use (`,` value-use)*
  final public void ValueUseList() throws ParseException {
                      /*@bgen(jjtree) ValueUseList */
  SimpleNode jjtn000 = new SimpleNode(JJTVALUEUSELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ValueUse();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 18:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_6;
        }
        jj_consume_token(18);
        ValueUse();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// op-result            ::= value-id (`:` integer-literal)
  final public void OpResult() throws ParseException {
                  /*@bgen(jjtree) OpResult */
  SimpleNode jjtn000 = new SimpleNode(JJTOPRESULT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ValueId();
      jj_consume_token(21);
      IntegerLiteral();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// op-result-list       ::= op-result (`,` op-result)* `=`
  final public void OpResultList() throws ParseException {
                      /*@bgen(jjtree) OpResultList */
  SimpleNode jjtn000 = new SimpleNode(JJTOPRESULTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      OpResult();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 18:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_7;
        }
        jj_consume_token(18);
        OpResult();
      }
      jj_consume_token(22);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// caret-id        ::= `^` suffix-id
  final public void CaretId() throws ParseException {
                 /*@bgen(jjtree) CaretId */
  SimpleNode jjtn000 = new SimpleNode(JJTCARETID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(23);
      SuffixId();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/*

alias-name ::= bare-id

type-alias ::= '!' alias-name


dialect-namespace ::= bare-id

opaque-dialect-item ::= dialect-namespace '<' string-literal '>'

pretty-dialect-item-lead-ident ::= '[A-Za-z][A-Za-z0-9._]*'

pretty-dialect-item-body ::= '<' pretty-dialect-item-contents+ '>'

pretty-dialect-item-contents ::= pretty-dialect-item-body
                              | '(' pretty-dialect-item-contents+ ')'
                              | '[' pretty-dialect-item-contents+ ']'
                              | '{' pretty-dialect-item-contents+ '}'
                              | '[^[<({>\])}\0]+'

pretty-dialect-item ::= dialect-namespace '.' pretty-dialect-item-lead-ident
                                              pretty-dialect-item-body?





dialect-type ::= '!' opaque-dialect-item
dialect-type ::= '!' pretty-dialect-item


builtin-type ::= https://mlir.llvm.org/docs/Dialects/Builtin/


type ::= type-alias | dialect-type | builtin-type


*/




// value-id-and-type ::= value-id `:` type
  final public void ValueIdAndType() throws ParseException {
                        /*@bgen(jjtree) ValueIdAndType */
  SimpleNode jjtn000 = new SimpleNode(JJTVALUEIDANDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ValueId();
      jj_consume_token(21);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// Non-empty list of names and types.
//value-id-and-type-list ::= value-id-and-type (`,` value-id-and-type)*

// block-arg-list ::= `(` value-id-and-type-list? `)`



// successor            ::= caret-id (`:` block-arg-list)?


// successor-list       ::= `[` successor (`,` successor)* `]`


/*
block-id        ::= caret-id
block-label     ::= block-id block-arg-list? `:`
block           ::= block-label operation+

region ::= `{` block* `}`

region-list          ::= `(` region (`,` region)* `)`
*/


//dictionary-attribute ::= `{` (attribute-entry (`,` attribute-entry)*)? `}`

// function-type ::= type

// generic-operation    ::= string-literal `(` value-use-list? `)`  successor-list? region-list? dictionary-attribute? `:` function-type
  final public void GenericOperation() throws ParseException {
                          /*@bgen(jjtree) GenericOperation */
  SimpleNode jjtn000 = new SimpleNode(JJTGENERICOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(STRING_LITERAL);
      jj_consume_token(24);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 19:
        ValueUseList();
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      jj_consume_token(25);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// custom-operation-format ???

// custom-operation     ::= bare-id custom-operation-format

// custom-operation not currently supported


// location ???

// trailing-location    ::= (`loc` `(` location `)`)?

// trailing-location not currently supported

// Full: operation            ::= op-result-list? (generic-operation | custom-operation) trailing-location?
// Current: operation            ::= op-result-list? generic-operation 
  final public void Operation() throws ParseException {
                   /*@bgen(jjtree) Operation */
  SimpleNode jjtn000 = new SimpleNode(JJTOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 19:
        OpResultList();
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      GenericOperation();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/*






































type-list-no-parens ::=  type (`,` type)*
type-list-parens ::= `(` `)`
                   | `(` type-list-no-parens `)`

// This is a common way to refer to a value with a specified type.
ssa-use-and-type ::= ssa-use `:` type

// Non-empty list of names and types.
ssa-use-and-type-list ::= ssa-use-and-type (`,` ssa-use-and-type)*




type-alias-def ::= '!' alias-name '=' 'type' type








attribute-entry ::= (bare-id | string-literal) `=` attribute-value
attribute-value ::= attribute-alias | dialect-attribute | builtin-attribute


attribute-alias-def ::= '#' alias-name '=' attribute-value
attribute-alias ::= '#' alias-name


dialect-attribute-value ::= '#' opaque-dialect-item
dialect-attribute-value ::= '#' pretty-dialect-item




*/
  final public SimpleNode Root() throws ParseException {
 /*@bgen(jjtree) Root */
  SimpleNode jjtn000 = new SimpleNode(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      IntegerLiteral();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public void IntegerLiteral() throws ParseException {
                         /*@bgen(jjtree) IntegerLiteral */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGERLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        jj_consume_token(DECIMAL_LITERAL);
        break;
      case HEXADECIMAL_LITERAL:
        jj_consume_token(HEXADECIMAL_LITERAL);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  /** Generated Token Manager. */
  public MlirParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[17];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3c000,0x10200,0x1c280,0x1c280,0x40000,0x80,0x3c200,0x3c280,0x3c280,0x3c280,0x3e280,0x40000,0x40000,0x40000,0x80000,0x80000,0xc00,};
   }

  /** Constructor with InputStream. */
  public MlirParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MlirParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MlirParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MlirParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MlirParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MlirParser(MlirParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MlirParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 17; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[26];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 17; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 26; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  /*  public static void main(String args [])  {    System.out.println("Reading from standard input...");    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");    Mlir parser = new Mlir(System.in);    try    {      SimpleNode n = parser.Start();      n.dump("");      System.out.println("Thank you.");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }
  */
}
